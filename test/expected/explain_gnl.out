--#
--#       Gpu Nest Loop Explain TestCases
--#
--#  [TODO] Gpu Nest Loop with Cross Join has not yet supported.
--#  [TODO] In depth larger than 1, Gpu Nest Loop has never been selected.
--#
set pg_strom.gpu_setup_cost=0;
set enable_nestloop to off;
--###
--### disabled pg_strom
--###
set pg_strom.enabled=off;
-- ## SMALLINT ##
-- Inner join
explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.smlint_x,s2.id as id2,s2.smlint_x from strom_test s1 inner join strom_test s2 on s1.key=1 and s2.key=2 and s1.smlint_x > s2.smlint_x) as t where t.rowid%10000=0;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.smlint_x, t.id2, t.smlint_x_1
   Filter: ((t.rowid % '10000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.smlint_x, s2.id, s2.smlint_x
         ->  Sort
               Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop
                     Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
                     Join Filter: (s1.smlint_x > s2.smlint_x)
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                           Filter: (s1.key = 1)
                     ->  Materialize
                           Output: s2.id, s2.smlint_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.smlint_x
                                 Filter: (s2.key = 2)
(19 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.smlint_x,s2.id as id2,s2.smlint_x from strom_test s1 inner join strom_test s2 on s1.key=1 and s2.key=2 and s1.smlint_x < s2.smlint_x) as t where t.rowid%10000=0;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.smlint_x, t.id2, t.smlint_x_1
   Filter: ((t.rowid % '10000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.smlint_x, s2.id, s2.smlint_x
         ->  Sort
               Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop
                     Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
                     Join Filter: (s1.smlint_x < s2.smlint_x)
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                           Filter: (s1.key = 1)
                     ->  Materialize
                           Output: s2.id, s2.smlint_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.smlint_x
                                 Filter: (s2.key = 2)
(19 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.smlint_x,s2.id as id2,s2.smlint_x from strom_test s1 inner join strom_test s2 on s1.key=1 and s2.key=2 and s1.smlint_x >= s2.smlint_x) as t where t.rowid%10000=0;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.smlint_x, t.id2, t.smlint_x_1
   Filter: ((t.rowid % '10000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.smlint_x, s2.id, s2.smlint_x
         ->  Sort
               Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop
                     Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
                     Join Filter: (s1.smlint_x >= s2.smlint_x)
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                           Filter: (s1.key = 1)
                     ->  Materialize
                           Output: s2.id, s2.smlint_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.smlint_x
                                 Filter: (s2.key = 2)
(19 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.smlint_x,s2.id as id2,s2.smlint_x from strom_test s1 inner join strom_test s2 on s1.key=1 and s2.key=2 and s1.smlint_x <= s2.smlint_x) as t where t.rowid%10000=0;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.smlint_x, t.id2, t.smlint_x_1
   Filter: ((t.rowid % '10000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.smlint_x, s2.id, s2.smlint_x
         ->  Sort
               Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop
                     Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
                     Join Filter: (s1.smlint_x <= s2.smlint_x)
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                           Filter: (s1.key = 1)
                     ->  Materialize
                           Output: s2.id, s2.smlint_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.smlint_x
                                 Filter: (s2.key = 2)
(19 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.smlint_x,s2.id as id2,s2.smlint_x from strom_test s1 inner join strom_test s2 on s1.key=1 and s2.key=2 and s1.smlint_x between s2.smlint_x and s2.smlint_x+100) as t where t.rowid%10000=0;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.smlint_x, t.id2, t.smlint_x_1
   Filter: ((t.rowid % '10000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.smlint_x, s2.id, s2.smlint_x
         ->  Sort
               Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop
                     Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
                     Join Filter: ((s1.smlint_x >= s2.smlint_x) AND (s1.smlint_x <= (s2.smlint_x + 100)))
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                           Filter: (s1.key = 1)
                     ->  Materialize
                           Output: s2.id, s2.smlint_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.smlint_x
                                 Filter: (s2.key = 2)
(19 rows)

--Left outer join
explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.smlint_x,s2.id as id2,s2.smlint_x from strom_test s1 left outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.smlint_x > s2.smlint_x) as t where t.rowid%1000 = 0 and t.id2 is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.smlint_x, t.id2, t.smlint_x_1
   Filter: ((t.id2 IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.smlint_x, s2.id, s2.smlint_x
         ->  Sort
               Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
                     Join Filter: ((s1.key = 1) AND (s1.smlint_x > s2.smlint_x))
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                     ->  Materialize
                           Output: s2.id, s2.smlint_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.smlint_x
                                 Filter: (s2.key = 2)
(18 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.smlint_x,s2.id as id2,s2.smlint_x from strom_test s1 left outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.smlint_x < s2.smlint_x) as t where t.rowid%1000 = 0 and t.id2 is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.smlint_x, t.id2, t.smlint_x_1
   Filter: ((t.id2 IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.smlint_x, s2.id, s2.smlint_x
         ->  Sort
               Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
                     Join Filter: ((s1.key = 1) AND (s1.smlint_x < s2.smlint_x))
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                     ->  Materialize
                           Output: s2.id, s2.smlint_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.smlint_x
                                 Filter: (s2.key = 2)
(18 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.smlint_x,s2.id as id2,s2.smlint_x from strom_test s1 left outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.smlint_x >= s2.smlint_x) as t where t.rowid%1000 = 0 and t.id2 is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.smlint_x, t.id2, t.smlint_x_1
   Filter: ((t.id2 IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.smlint_x, s2.id, s2.smlint_x
         ->  Sort
               Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
                     Join Filter: ((s1.key = 1) AND (s1.smlint_x >= s2.smlint_x))
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                     ->  Materialize
                           Output: s2.id, s2.smlint_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.smlint_x
                                 Filter: (s2.key = 2)
(18 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.smlint_x,s2.id as id2,s2.smlint_x from strom_test s1 left outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.smlint_x <= s2.smlint_x) as t where t.rowid%1000 = 0 and t.id2 is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.smlint_x, t.id2, t.smlint_x_1
   Filter: ((t.id2 IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.smlint_x, s2.id, s2.smlint_x
         ->  Sort
               Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
                     Join Filter: ((s1.key = 1) AND (s1.smlint_x <= s2.smlint_x))
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                     ->  Materialize
                           Output: s2.id, s2.smlint_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.smlint_x
                                 Filter: (s2.key = 2)
(18 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.smlint_x,s2.id as id2,s2.smlint_x from strom_test s1 left outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.smlint_x between s2.smlint_x and s2.smlint_x+100) as t where t.rowid%1000 = 0 and t.id2 is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.smlint_x, t.id2, t.smlint_x_1
   Filter: ((t.id2 IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.smlint_x, s2.id, s2.smlint_x
         ->  Sort
               Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
                     Join Filter: ((s1.key = 1) AND (s1.smlint_x >= s2.smlint_x) AND (s1.smlint_x <= (s2.smlint_x + 100)))
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                     ->  Materialize
                           Output: s2.id, s2.smlint_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.smlint_x
                                 Filter: (s2.key = 2)
(18 rows)

--Right Outer Join ( REVERSE inner and outer )
explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.smlint_x,s2.id as id2,s2.smlint_x from strom_test s1 right outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.smlint_x > s2.smlint_x) as t where t.rowid%1000 = 0 and t.id is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.smlint_x, t.id2, t.smlint_x_1
   Filter: ((t.id IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.smlint_x, s2.id, s2.smlint_x
         ->  Sort
               Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
                     Join Filter: ((s2.key = 2) AND (s1.smlint_x > s2.smlint_x))
                     ->  Seq Scan on public.strom_test s2
                           Output: s2.id, s2.key, s2.smlint_x, s2.integer_x, s2.bigint_x, s2.real_x, s2.float_x, s2.nume_x, s2.smlsrl_x, s2.serial_x, s2.bigsrl_x
                     ->  Materialize
                           Output: s1.id, s1.smlint_x
                           ->  Seq Scan on public.strom_test s1
                                 Output: s1.id, s1.smlint_x
                                 Filter: (s1.key = 1)
(18 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.smlint_x,s2.id as id2,s2.smlint_x from strom_test s1 right outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.smlint_x < s2.smlint_x) as t where t.rowid%1000 = 0 and t.id is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.smlint_x, t.id2, t.smlint_x_1
   Filter: ((t.id IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.smlint_x, s2.id, s2.smlint_x
         ->  Sort
               Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
                     Join Filter: ((s2.key = 2) AND (s1.smlint_x < s2.smlint_x))
                     ->  Seq Scan on public.strom_test s2
                           Output: s2.id, s2.key, s2.smlint_x, s2.integer_x, s2.bigint_x, s2.real_x, s2.float_x, s2.nume_x, s2.smlsrl_x, s2.serial_x, s2.bigsrl_x
                     ->  Materialize
                           Output: s1.id, s1.smlint_x
                           ->  Seq Scan on public.strom_test s1
                                 Output: s1.id, s1.smlint_x
                                 Filter: (s1.key = 1)
(18 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.smlint_x,s2.id as id2,s2.smlint_x from strom_test s1 right outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.smlint_x >= s2.smlint_x) as t where t.rowid%1000 = 0 and t.id is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.smlint_x, t.id2, t.smlint_x_1
   Filter: ((t.id IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.smlint_x, s2.id, s2.smlint_x
         ->  Sort
               Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
                     Join Filter: ((s2.key = 2) AND (s1.smlint_x >= s2.smlint_x))
                     ->  Seq Scan on public.strom_test s2
                           Output: s2.id, s2.key, s2.smlint_x, s2.integer_x, s2.bigint_x, s2.real_x, s2.float_x, s2.nume_x, s2.smlsrl_x, s2.serial_x, s2.bigsrl_x
                     ->  Materialize
                           Output: s1.id, s1.smlint_x
                           ->  Seq Scan on public.strom_test s1
                                 Output: s1.id, s1.smlint_x
                                 Filter: (s1.key = 1)
(18 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.smlint_x,s2.id as id2,s2.smlint_x from strom_test s1 right outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.smlint_x <= s2.smlint_x) as t where t.rowid%1000 = 0 and t.id is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.smlint_x, t.id2, t.smlint_x_1
   Filter: ((t.id IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.smlint_x, s2.id, s2.smlint_x
         ->  Sort
               Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
                     Join Filter: ((s2.key = 2) AND (s1.smlint_x <= s2.smlint_x))
                     ->  Seq Scan on public.strom_test s2
                           Output: s2.id, s2.key, s2.smlint_x, s2.integer_x, s2.bigint_x, s2.real_x, s2.float_x, s2.nume_x, s2.smlsrl_x, s2.serial_x, s2.bigsrl_x
                     ->  Materialize
                           Output: s1.id, s1.smlint_x
                           ->  Seq Scan on public.strom_test s1
                                 Output: s1.id, s1.smlint_x
                                 Filter: (s1.key = 1)
(18 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.smlint_x,s2.id as id2,s2.smlint_x from strom_test s1 right outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.smlint_x between s2.smlint_x and s2.smlint_x+100) as t where t.rowid%1000 = 0 and t.id is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.smlint_x, t.id2, t.smlint_x_1
   Filter: ((t.id IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.smlint_x, s2.id, s2.smlint_x
         ->  Sort
               Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
                     Join Filter: ((s2.key = 2) AND (s1.smlint_x >= s2.smlint_x) AND (s1.smlint_x <= (s2.smlint_x + 100)))
                     ->  Seq Scan on public.strom_test s2
                           Output: s2.id, s2.key, s2.smlint_x, s2.integer_x, s2.bigint_x, s2.real_x, s2.float_x, s2.nume_x, s2.smlsrl_x, s2.serial_x, s2.bigsrl_x
                     ->  Materialize
                           Output: s1.id, s1.smlint_x
                           ->  Seq Scan on public.strom_test s1
                                 Output: s1.id, s1.smlint_x
                                 Filter: (s1.key = 1)
(18 rows)

--Full Join ( NOT supported error )
explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.smlint_x,s2.id as id2,s2.smlint_x from strom_test s1 FULL join strom_test s2 on s1.key=1 and s2.key=2 and s1.smlint_x > s2.smlint_x) as t where t.rowid%1000 = 0 and t.id is NULL;
ERROR:  FULL JOIN is only supported with merge-joinable or hash-joinable join conditions
-- ## FLOAT ##
-- Inner join
explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.float_x,s2.id as id2,s2.float_x from strom_test s1 inner join strom_test s2 on s1.key=1 and s2.key=2 and s1.float_x > s2.float_x) as t where t.rowid%10000=0;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.float_x, t.id2, t.float_x_1
   Filter: ((t.rowid % '10000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.float_x, s2.id, s2.float_x
         ->  Sort
               Output: s1.id, s2.id, s1.float_x, s2.float_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop
                     Output: s1.id, s2.id, s1.float_x, s2.float_x
                     Join Filter: (s1.float_x > s2.float_x)
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                           Filter: (s1.key = 1)
                     ->  Materialize
                           Output: s2.id, s2.float_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.float_x
                                 Filter: (s2.key = 2)
(19 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.float_x,s2.id as id2,s2.float_x from strom_test s1 inner join strom_test s2 on s1.key=1 and s2.key=2 and s1.float_x < s2.float_x) as t where t.rowid%10000=0;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.float_x, t.id2, t.float_x_1
   Filter: ((t.rowid % '10000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.float_x, s2.id, s2.float_x
         ->  Sort
               Output: s1.id, s2.id, s1.float_x, s2.float_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop
                     Output: s1.id, s2.id, s1.float_x, s2.float_x
                     Join Filter: (s1.float_x < s2.float_x)
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                           Filter: (s1.key = 1)
                     ->  Materialize
                           Output: s2.id, s2.float_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.float_x
                                 Filter: (s2.key = 2)
(19 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.float_x,s2.id as id2,s2.float_x from strom_test s1 inner join strom_test s2 on s1.key=1 and s2.key=2 and s1.float_x >= s2.float_x) as t where t.rowid%10000=0;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.float_x, t.id2, t.float_x_1
   Filter: ((t.rowid % '10000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.float_x, s2.id, s2.float_x
         ->  Sort
               Output: s1.id, s2.id, s1.float_x, s2.float_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop
                     Output: s1.id, s2.id, s1.float_x, s2.float_x
                     Join Filter: (s1.float_x >= s2.float_x)
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                           Filter: (s1.key = 1)
                     ->  Materialize
                           Output: s2.id, s2.float_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.float_x
                                 Filter: (s2.key = 2)
(19 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.float_x,s2.id as id2,s2.float_x from strom_test s1 inner join strom_test s2 on s1.key=1 and s2.key=2 and s1.float_x <= s2.float_x) as t where t.rowid%10000=0;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.float_x, t.id2, t.float_x_1
   Filter: ((t.rowid % '10000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.float_x, s2.id, s2.float_x
         ->  Sort
               Output: s1.id, s2.id, s1.float_x, s2.float_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop
                     Output: s1.id, s2.id, s1.float_x, s2.float_x
                     Join Filter: (s1.float_x <= s2.float_x)
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                           Filter: (s1.key = 1)
                     ->  Materialize
                           Output: s2.id, s2.float_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.float_x
                                 Filter: (s2.key = 2)
(19 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.float_x,s2.id as id2,s2.float_x from strom_test s1 inner join strom_test s2 on s1.key=1 and s2.key=2 and s1.float_x between s2.float_x and s2.float_x+0.05) as t where t.rowid%1000=0;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.float_x, t.id2, t.float_x_1
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.float_x, s2.id, s2.float_x
         ->  Sort
               Output: s1.id, s2.id, s1.float_x, s2.float_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop
                     Output: s1.id, s2.id, s1.float_x, s2.float_x
                     Join Filter: ((s1.float_x >= s2.float_x) AND (s1.float_x <= (s2.float_x + '0.05'::double precision)))
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                           Filter: (s1.key = 1)
                     ->  Materialize
                           Output: s2.id, s2.float_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.float_x
                                 Filter: (s2.key = 2)
(19 rows)

--Left outer join
explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.float_x,s2.id as id2,s2.float_x from strom_test s1 left outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.float_x > s2.float_x) as t where t.rowid%1000 = 0 and t.id2 is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.float_x, t.id2, t.float_x_1
   Filter: ((t.id2 IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.float_x, s2.id, s2.float_x
         ->  Sort
               Output: s1.id, s2.id, s1.float_x, s2.float_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.float_x, s2.float_x
                     Join Filter: ((s1.key = 1) AND (s1.float_x > s2.float_x))
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                     ->  Materialize
                           Output: s2.id, s2.float_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.float_x
                                 Filter: (s2.key = 2)
(18 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.float_x,s2.id as id2,s2.float_x from strom_test s1 left outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.float_x < s2.float_x) as t where t.rowid%1000 = 0 and t.id2 is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.float_x, t.id2, t.float_x_1
   Filter: ((t.id2 IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.float_x, s2.id, s2.float_x
         ->  Sort
               Output: s1.id, s2.id, s1.float_x, s2.float_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.float_x, s2.float_x
                     Join Filter: ((s1.key = 1) AND (s1.float_x < s2.float_x))
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                     ->  Materialize
                           Output: s2.id, s2.float_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.float_x
                                 Filter: (s2.key = 2)
(18 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.float_x,s2.id as id2,s2.float_x from strom_test s1 left outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.float_x >= s2.float_x) as t where t.rowid%1000 = 0 and t.id2 is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.float_x, t.id2, t.float_x_1
   Filter: ((t.id2 IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.float_x, s2.id, s2.float_x
         ->  Sort
               Output: s1.id, s2.id, s1.float_x, s2.float_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.float_x, s2.float_x
                     Join Filter: ((s1.key = 1) AND (s1.float_x >= s2.float_x))
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                     ->  Materialize
                           Output: s2.id, s2.float_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.float_x
                                 Filter: (s2.key = 2)
(18 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.float_x,s2.id as id2,s2.float_x from strom_test s1 left outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.float_x <= s2.float_x) as t where t.rowid%1000 = 0 and t.id2 is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.float_x, t.id2, t.float_x_1
   Filter: ((t.id2 IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.float_x, s2.id, s2.float_x
         ->  Sort
               Output: s1.id, s2.id, s1.float_x, s2.float_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.float_x, s2.float_x
                     Join Filter: ((s1.key = 1) AND (s1.float_x <= s2.float_x))
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                     ->  Materialize
                           Output: s2.id, s2.float_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.float_x
                                 Filter: (s2.key = 2)
(18 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.float_x,s2.id as id2,s2.float_x from strom_test s1 left outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.float_x between s2.float_x and s2.float_x+0.05) as t where t.rowid%1000 = 0 and t.id2 is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.float_x, t.id2, t.float_x_1
   Filter: ((t.id2 IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.float_x, s2.id, s2.float_x
         ->  Sort
               Output: s1.id, s2.id, s1.float_x, s2.float_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.float_x, s2.float_x
                     Join Filter: ((s1.key = 1) AND (s1.float_x >= s2.float_x) AND (s1.float_x <= (s2.float_x + '0.05'::double precision)))
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                     ->  Materialize
                           Output: s2.id, s2.float_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.float_x
                                 Filter: (s2.key = 2)
(18 rows)

--Right Outer Join ( REVERSE inner and outer )
explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.float_x,s2.id as id2,s2.float_x from strom_test s1 right outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.float_x > s2.float_x) as t where t.rowid%1000 = 0 and t.id is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.float_x, t.id2, t.float_x_1
   Filter: ((t.id IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.float_x, s2.id, s2.float_x
         ->  Sort
               Output: s1.id, s2.id, s1.float_x, s2.float_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.float_x, s2.float_x
                     Join Filter: ((s2.key = 2) AND (s1.float_x > s2.float_x))
                     ->  Seq Scan on public.strom_test s2
                           Output: s2.id, s2.key, s2.smlint_x, s2.integer_x, s2.bigint_x, s2.real_x, s2.float_x, s2.nume_x, s2.smlsrl_x, s2.serial_x, s2.bigsrl_x
                     ->  Materialize
                           Output: s1.id, s1.float_x
                           ->  Seq Scan on public.strom_test s1
                                 Output: s1.id, s1.float_x
                                 Filter: (s1.key = 1)
(18 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.float_x,s2.id as id2,s2.float_x from strom_test s1 right outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.float_x < s2.float_x) as t where t.rowid%1000 = 0 and t.id is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.float_x, t.id2, t.float_x_1
   Filter: ((t.id IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.float_x, s2.id, s2.float_x
         ->  Sort
               Output: s1.id, s2.id, s1.float_x, s2.float_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.float_x, s2.float_x
                     Join Filter: ((s2.key = 2) AND (s1.float_x < s2.float_x))
                     ->  Seq Scan on public.strom_test s2
                           Output: s2.id, s2.key, s2.smlint_x, s2.integer_x, s2.bigint_x, s2.real_x, s2.float_x, s2.nume_x, s2.smlsrl_x, s2.serial_x, s2.bigsrl_x
                     ->  Materialize
                           Output: s1.id, s1.float_x
                           ->  Seq Scan on public.strom_test s1
                                 Output: s1.id, s1.float_x
                                 Filter: (s1.key = 1)
(18 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.float_x,s2.id as id2,s2.float_x from strom_test s1 right outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.float_x >= s2.float_x) as t where t.rowid%1000 = 0 and t.id is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.float_x, t.id2, t.float_x_1
   Filter: ((t.id IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.float_x, s2.id, s2.float_x
         ->  Sort
               Output: s1.id, s2.id, s1.float_x, s2.float_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.float_x, s2.float_x
                     Join Filter: ((s2.key = 2) AND (s1.float_x >= s2.float_x))
                     ->  Seq Scan on public.strom_test s2
                           Output: s2.id, s2.key, s2.smlint_x, s2.integer_x, s2.bigint_x, s2.real_x, s2.float_x, s2.nume_x, s2.smlsrl_x, s2.serial_x, s2.bigsrl_x
                     ->  Materialize
                           Output: s1.id, s1.float_x
                           ->  Seq Scan on public.strom_test s1
                                 Output: s1.id, s1.float_x
                                 Filter: (s1.key = 1)
(18 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.float_x,s2.id as id2,s2.float_x from strom_test s1 right outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.float_x <= s2.float_x) as t where t.rowid%1000 = 0 and t.id is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.float_x, t.id2, t.float_x_1
   Filter: ((t.id IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.float_x, s2.id, s2.float_x
         ->  Sort
               Output: s1.id, s2.id, s1.float_x, s2.float_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.float_x, s2.float_x
                     Join Filter: ((s2.key = 2) AND (s1.float_x <= s2.float_x))
                     ->  Seq Scan on public.strom_test s2
                           Output: s2.id, s2.key, s2.smlint_x, s2.integer_x, s2.bigint_x, s2.real_x, s2.float_x, s2.nume_x, s2.smlsrl_x, s2.serial_x, s2.bigsrl_x
                     ->  Materialize
                           Output: s1.id, s1.float_x
                           ->  Seq Scan on public.strom_test s1
                                 Output: s1.id, s1.float_x
                                 Filter: (s1.key = 1)
(18 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.float_x,s2.id as id2,s2.float_x from strom_test s1 right outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.float_x between s2.float_x and s2.float_x+0.05) as t where t.rowid%1000 = 0 and t.id is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.float_x, t.id2, t.float_x_1
   Filter: ((t.id IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.float_x, s2.id, s2.float_x
         ->  Sort
               Output: s1.id, s2.id, s1.float_x, s2.float_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.float_x, s2.float_x
                     Join Filter: ((s2.key = 2) AND (s1.float_x >= s2.float_x) AND (s1.float_x <= (s2.float_x + '0.05'::double precision)))
                     ->  Seq Scan on public.strom_test s2
                           Output: s2.id, s2.key, s2.smlint_x, s2.integer_x, s2.bigint_x, s2.real_x, s2.float_x, s2.nume_x, s2.smlsrl_x, s2.serial_x, s2.bigsrl_x
                     ->  Materialize
                           Output: s1.id, s1.float_x
                           ->  Seq Scan on public.strom_test s1
                                 Output: s1.id, s1.float_x
                                 Filter: (s1.key = 1)
(18 rows)

--Full Join ( NOT supported error )
explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.float_x,s2.id as id2,s2.float_x from strom_test s1 FULL join strom_test s2 on s1.key=1 and s2.key=2 and s1.float_x > s2.float_x) as t where t.rowid%1000 = 0 and t.id is NULL;
ERROR:  FULL JOIN is only supported with merge-joinable or hash-joinable join conditions
--###
--### enabled pg_strom
--###
set pg_strom.enabled=off;
-- ## SMALLINT ##
-- Inner join
explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.smlint_x,s2.id as id2,s2.smlint_x from strom_test s1 inner join strom_test s2 on s1.key=1 and s2.key=2 and s1.smlint_x > s2.smlint_x) as t where t.rowid%10000=0;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.smlint_x, t.id2, t.smlint_x_1
   Filter: ((t.rowid % '10000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.smlint_x, s2.id, s2.smlint_x
         ->  Sort
               Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop
                     Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
                     Join Filter: (s1.smlint_x > s2.smlint_x)
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                           Filter: (s1.key = 1)
                     ->  Materialize
                           Output: s2.id, s2.smlint_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.smlint_x
                                 Filter: (s2.key = 2)
(19 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.smlint_x,s2.id as id2,s2.smlint_x from strom_test s1 inner join strom_test s2 on s1.key=1 and s2.key=2 and s1.smlint_x < s2.smlint_x) as t where t.rowid%10000=0;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.smlint_x, t.id2, t.smlint_x_1
   Filter: ((t.rowid % '10000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.smlint_x, s2.id, s2.smlint_x
         ->  Sort
               Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop
                     Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
                     Join Filter: (s1.smlint_x < s2.smlint_x)
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                           Filter: (s1.key = 1)
                     ->  Materialize
                           Output: s2.id, s2.smlint_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.smlint_x
                                 Filter: (s2.key = 2)
(19 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.smlint_x,s2.id as id2,s2.smlint_x from strom_test s1 inner join strom_test s2 on s1.key=1 and s2.key=2 and s1.smlint_x >= s2.smlint_x) as t where t.rowid%10000=0;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.smlint_x, t.id2, t.smlint_x_1
   Filter: ((t.rowid % '10000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.smlint_x, s2.id, s2.smlint_x
         ->  Sort
               Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop
                     Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
                     Join Filter: (s1.smlint_x >= s2.smlint_x)
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                           Filter: (s1.key = 1)
                     ->  Materialize
                           Output: s2.id, s2.smlint_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.smlint_x
                                 Filter: (s2.key = 2)
(19 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.smlint_x,s2.id as id2,s2.smlint_x from strom_test s1 inner join strom_test s2 on s1.key=1 and s2.key=2 and s1.smlint_x <= s2.smlint_x) as t where t.rowid%10000=0;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.smlint_x, t.id2, t.smlint_x_1
   Filter: ((t.rowid % '10000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.smlint_x, s2.id, s2.smlint_x
         ->  Sort
               Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop
                     Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
                     Join Filter: (s1.smlint_x <= s2.smlint_x)
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                           Filter: (s1.key = 1)
                     ->  Materialize
                           Output: s2.id, s2.smlint_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.smlint_x
                                 Filter: (s2.key = 2)
(19 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.smlint_x,s2.id as id2,s2.smlint_x from strom_test s1 inner join strom_test s2 on s1.key=1 and s2.key=2 and s1.smlint_x between s2.smlint_x and s2.smlint_x+100) as t where t.rowid%10000=0;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.smlint_x, t.id2, t.smlint_x_1
   Filter: ((t.rowid % '10000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.smlint_x, s2.id, s2.smlint_x
         ->  Sort
               Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop
                     Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
                     Join Filter: ((s1.smlint_x >= s2.smlint_x) AND (s1.smlint_x <= (s2.smlint_x + 100)))
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                           Filter: (s1.key = 1)
                     ->  Materialize
                           Output: s2.id, s2.smlint_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.smlint_x
                                 Filter: (s2.key = 2)
(19 rows)

--Left outer join
explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.smlint_x,s2.id as id2,s2.smlint_x from strom_test s1 left outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.smlint_x > s2.smlint_x) as t where t.rowid%1000 = 0 and t.id2 is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.smlint_x, t.id2, t.smlint_x_1
   Filter: ((t.id2 IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.smlint_x, s2.id, s2.smlint_x
         ->  Sort
               Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
                     Join Filter: ((s1.key = 1) AND (s1.smlint_x > s2.smlint_x))
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                     ->  Materialize
                           Output: s2.id, s2.smlint_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.smlint_x
                                 Filter: (s2.key = 2)
(18 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.smlint_x,s2.id as id2,s2.smlint_x from strom_test s1 left outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.smlint_x < s2.smlint_x) as t where t.rowid%1000 = 0 and t.id2 is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.smlint_x, t.id2, t.smlint_x_1
   Filter: ((t.id2 IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.smlint_x, s2.id, s2.smlint_x
         ->  Sort
               Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
                     Join Filter: ((s1.key = 1) AND (s1.smlint_x < s2.smlint_x))
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                     ->  Materialize
                           Output: s2.id, s2.smlint_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.smlint_x
                                 Filter: (s2.key = 2)
(18 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.smlint_x,s2.id as id2,s2.smlint_x from strom_test s1 left outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.smlint_x >= s2.smlint_x) as t where t.rowid%1000 = 0 and t.id2 is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.smlint_x, t.id2, t.smlint_x_1
   Filter: ((t.id2 IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.smlint_x, s2.id, s2.smlint_x
         ->  Sort
               Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
                     Join Filter: ((s1.key = 1) AND (s1.smlint_x >= s2.smlint_x))
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                     ->  Materialize
                           Output: s2.id, s2.smlint_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.smlint_x
                                 Filter: (s2.key = 2)
(18 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.smlint_x,s2.id as id2,s2.smlint_x from strom_test s1 left outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.smlint_x <= s2.smlint_x) as t where t.rowid%1000 = 0 and t.id2 is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.smlint_x, t.id2, t.smlint_x_1
   Filter: ((t.id2 IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.smlint_x, s2.id, s2.smlint_x
         ->  Sort
               Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
                     Join Filter: ((s1.key = 1) AND (s1.smlint_x <= s2.smlint_x))
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                     ->  Materialize
                           Output: s2.id, s2.smlint_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.smlint_x
                                 Filter: (s2.key = 2)
(18 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.smlint_x,s2.id as id2,s2.smlint_x from strom_test s1 left outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.smlint_x between s2.smlint_x and s2.smlint_x+100) as t where t.rowid%1000 = 0 and t.id2 is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.smlint_x, t.id2, t.smlint_x_1
   Filter: ((t.id2 IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.smlint_x, s2.id, s2.smlint_x
         ->  Sort
               Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
                     Join Filter: ((s1.key = 1) AND (s1.smlint_x >= s2.smlint_x) AND (s1.smlint_x <= (s2.smlint_x + 100)))
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                     ->  Materialize
                           Output: s2.id, s2.smlint_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.smlint_x
                                 Filter: (s2.key = 2)
(18 rows)

--Right Outer Join ( REVERSE inner and outer )
explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.smlint_x,s2.id as id2,s2.smlint_x from strom_test s1 right outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.smlint_x > s2.smlint_x) as t where t.rowid%1000 = 0 and t.id is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.smlint_x, t.id2, t.smlint_x_1
   Filter: ((t.id IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.smlint_x, s2.id, s2.smlint_x
         ->  Sort
               Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
                     Join Filter: ((s2.key = 2) AND (s1.smlint_x > s2.smlint_x))
                     ->  Seq Scan on public.strom_test s2
                           Output: s2.id, s2.key, s2.smlint_x, s2.integer_x, s2.bigint_x, s2.real_x, s2.float_x, s2.nume_x, s2.smlsrl_x, s2.serial_x, s2.bigsrl_x
                     ->  Materialize
                           Output: s1.id, s1.smlint_x
                           ->  Seq Scan on public.strom_test s1
                                 Output: s1.id, s1.smlint_x
                                 Filter: (s1.key = 1)
(18 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.smlint_x,s2.id as id2,s2.smlint_x from strom_test s1 right outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.smlint_x < s2.smlint_x) as t where t.rowid%1000 = 0 and t.id is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.smlint_x, t.id2, t.smlint_x_1
   Filter: ((t.id IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.smlint_x, s2.id, s2.smlint_x
         ->  Sort
               Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
                     Join Filter: ((s2.key = 2) AND (s1.smlint_x < s2.smlint_x))
                     ->  Seq Scan on public.strom_test s2
                           Output: s2.id, s2.key, s2.smlint_x, s2.integer_x, s2.bigint_x, s2.real_x, s2.float_x, s2.nume_x, s2.smlsrl_x, s2.serial_x, s2.bigsrl_x
                     ->  Materialize
                           Output: s1.id, s1.smlint_x
                           ->  Seq Scan on public.strom_test s1
                                 Output: s1.id, s1.smlint_x
                                 Filter: (s1.key = 1)
(18 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.smlint_x,s2.id as id2,s2.smlint_x from strom_test s1 right outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.smlint_x >= s2.smlint_x) as t where t.rowid%1000 = 0 and t.id is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.smlint_x, t.id2, t.smlint_x_1
   Filter: ((t.id IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.smlint_x, s2.id, s2.smlint_x
         ->  Sort
               Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
                     Join Filter: ((s2.key = 2) AND (s1.smlint_x >= s2.smlint_x))
                     ->  Seq Scan on public.strom_test s2
                           Output: s2.id, s2.key, s2.smlint_x, s2.integer_x, s2.bigint_x, s2.real_x, s2.float_x, s2.nume_x, s2.smlsrl_x, s2.serial_x, s2.bigsrl_x
                     ->  Materialize
                           Output: s1.id, s1.smlint_x
                           ->  Seq Scan on public.strom_test s1
                                 Output: s1.id, s1.smlint_x
                                 Filter: (s1.key = 1)
(18 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.smlint_x,s2.id as id2,s2.smlint_x from strom_test s1 right outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.smlint_x <= s2.smlint_x) as t where t.rowid%1000 = 0 and t.id is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.smlint_x, t.id2, t.smlint_x_1
   Filter: ((t.id IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.smlint_x, s2.id, s2.smlint_x
         ->  Sort
               Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
                     Join Filter: ((s2.key = 2) AND (s1.smlint_x <= s2.smlint_x))
                     ->  Seq Scan on public.strom_test s2
                           Output: s2.id, s2.key, s2.smlint_x, s2.integer_x, s2.bigint_x, s2.real_x, s2.float_x, s2.nume_x, s2.smlsrl_x, s2.serial_x, s2.bigsrl_x
                     ->  Materialize
                           Output: s1.id, s1.smlint_x
                           ->  Seq Scan on public.strom_test s1
                                 Output: s1.id, s1.smlint_x
                                 Filter: (s1.key = 1)
(18 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.smlint_x,s2.id as id2,s2.smlint_x from strom_test s1 right outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.smlint_x between s2.smlint_x and s2.smlint_x+100) as t where t.rowid%1000 = 0 and t.id is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.smlint_x, t.id2, t.smlint_x_1
   Filter: ((t.id IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.smlint_x, s2.id, s2.smlint_x
         ->  Sort
               Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.smlint_x, s2.smlint_x
                     Join Filter: ((s2.key = 2) AND (s1.smlint_x >= s2.smlint_x) AND (s1.smlint_x <= (s2.smlint_x + 100)))
                     ->  Seq Scan on public.strom_test s2
                           Output: s2.id, s2.key, s2.smlint_x, s2.integer_x, s2.bigint_x, s2.real_x, s2.float_x, s2.nume_x, s2.smlsrl_x, s2.serial_x, s2.bigsrl_x
                     ->  Materialize
                           Output: s1.id, s1.smlint_x
                           ->  Seq Scan on public.strom_test s1
                                 Output: s1.id, s1.smlint_x
                                 Filter: (s1.key = 1)
(18 rows)

--Full Join ( NOT supported error )
explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.smlint_x,s2.id as id2,s2.smlint_x from strom_test s1 FULL join strom_test s2 on s1.key=1 and s2.key=2 and s1.smlint_x > s2.smlint_x) as t where t.rowid%1000 = 0 and t.id is NULL;
ERROR:  FULL JOIN is only supported with merge-joinable or hash-joinable join conditions
-- ## FLOAT ##
-- Inner join
explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.float_x,s2.id as id2,s2.float_x from strom_test s1 inner join strom_test s2 on s1.key=1 and s2.key=2 and s1.float_x > s2.float_x) as t where t.rowid%10000=0;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.float_x, t.id2, t.float_x_1
   Filter: ((t.rowid % '10000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.float_x, s2.id, s2.float_x
         ->  Sort
               Output: s1.id, s2.id, s1.float_x, s2.float_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop
                     Output: s1.id, s2.id, s1.float_x, s2.float_x
                     Join Filter: (s1.float_x > s2.float_x)
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                           Filter: (s1.key = 1)
                     ->  Materialize
                           Output: s2.id, s2.float_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.float_x
                                 Filter: (s2.key = 2)
(19 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.float_x,s2.id as id2,s2.float_x from strom_test s1 inner join strom_test s2 on s1.key=1 and s2.key=2 and s1.float_x < s2.float_x) as t where t.rowid%10000=0;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.float_x, t.id2, t.float_x_1
   Filter: ((t.rowid % '10000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.float_x, s2.id, s2.float_x
         ->  Sort
               Output: s1.id, s2.id, s1.float_x, s2.float_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop
                     Output: s1.id, s2.id, s1.float_x, s2.float_x
                     Join Filter: (s1.float_x < s2.float_x)
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                           Filter: (s1.key = 1)
                     ->  Materialize
                           Output: s2.id, s2.float_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.float_x
                                 Filter: (s2.key = 2)
(19 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.float_x,s2.id as id2,s2.float_x from strom_test s1 inner join strom_test s2 on s1.key=1 and s2.key=2 and s1.float_x >= s2.float_x) as t where t.rowid%10000=0;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.float_x, t.id2, t.float_x_1
   Filter: ((t.rowid % '10000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.float_x, s2.id, s2.float_x
         ->  Sort
               Output: s1.id, s2.id, s1.float_x, s2.float_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop
                     Output: s1.id, s2.id, s1.float_x, s2.float_x
                     Join Filter: (s1.float_x >= s2.float_x)
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                           Filter: (s1.key = 1)
                     ->  Materialize
                           Output: s2.id, s2.float_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.float_x
                                 Filter: (s2.key = 2)
(19 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.float_x,s2.id as id2,s2.float_x from strom_test s1 inner join strom_test s2 on s1.key=1 and s2.key=2 and s1.float_x <= s2.float_x) as t where t.rowid%10000=0;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.float_x, t.id2, t.float_x_1
   Filter: ((t.rowid % '10000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.float_x, s2.id, s2.float_x
         ->  Sort
               Output: s1.id, s2.id, s1.float_x, s2.float_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop
                     Output: s1.id, s2.id, s1.float_x, s2.float_x
                     Join Filter: (s1.float_x <= s2.float_x)
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                           Filter: (s1.key = 1)
                     ->  Materialize
                           Output: s2.id, s2.float_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.float_x
                                 Filter: (s2.key = 2)
(19 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.float_x,s2.id as id2,s2.float_x from strom_test s1 inner join strom_test s2 on s1.key=1 and s2.key=2 and s1.float_x between s2.float_x and s2.float_x+0.05) as t where t.rowid%1000=0;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.float_x, t.id2, t.float_x_1
   Filter: ((t.rowid % '1000'::bigint) = 0)
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.float_x, s2.id, s2.float_x
         ->  Sort
               Output: s1.id, s2.id, s1.float_x, s2.float_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop
                     Output: s1.id, s2.id, s1.float_x, s2.float_x
                     Join Filter: ((s1.float_x >= s2.float_x) AND (s1.float_x <= (s2.float_x + '0.05'::double precision)))
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                           Filter: (s1.key = 1)
                     ->  Materialize
                           Output: s2.id, s2.float_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.float_x
                                 Filter: (s2.key = 2)
(19 rows)

--Left outer join
explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.float_x,s2.id as id2,s2.float_x from strom_test s1 left outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.float_x > s2.float_x) as t where t.rowid%1000 = 0 and t.id2 is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.float_x, t.id2, t.float_x_1
   Filter: ((t.id2 IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.float_x, s2.id, s2.float_x
         ->  Sort
               Output: s1.id, s2.id, s1.float_x, s2.float_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.float_x, s2.float_x
                     Join Filter: ((s1.key = 1) AND (s1.float_x > s2.float_x))
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                     ->  Materialize
                           Output: s2.id, s2.float_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.float_x
                                 Filter: (s2.key = 2)
(18 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.float_x,s2.id as id2,s2.float_x from strom_test s1 left outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.float_x < s2.float_x) as t where t.rowid%1000 = 0 and t.id2 is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.float_x, t.id2, t.float_x_1
   Filter: ((t.id2 IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.float_x, s2.id, s2.float_x
         ->  Sort
               Output: s1.id, s2.id, s1.float_x, s2.float_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.float_x, s2.float_x
                     Join Filter: ((s1.key = 1) AND (s1.float_x < s2.float_x))
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                     ->  Materialize
                           Output: s2.id, s2.float_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.float_x
                                 Filter: (s2.key = 2)
(18 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.float_x,s2.id as id2,s2.float_x from strom_test s1 left outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.float_x >= s2.float_x) as t where t.rowid%1000 = 0 and t.id2 is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.float_x, t.id2, t.float_x_1
   Filter: ((t.id2 IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.float_x, s2.id, s2.float_x
         ->  Sort
               Output: s1.id, s2.id, s1.float_x, s2.float_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.float_x, s2.float_x
                     Join Filter: ((s1.key = 1) AND (s1.float_x >= s2.float_x))
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                     ->  Materialize
                           Output: s2.id, s2.float_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.float_x
                                 Filter: (s2.key = 2)
(18 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.float_x,s2.id as id2,s2.float_x from strom_test s1 left outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.float_x <= s2.float_x) as t where t.rowid%1000 = 0 and t.id2 is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.float_x, t.id2, t.float_x_1
   Filter: ((t.id2 IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.float_x, s2.id, s2.float_x
         ->  Sort
               Output: s1.id, s2.id, s1.float_x, s2.float_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.float_x, s2.float_x
                     Join Filter: ((s1.key = 1) AND (s1.float_x <= s2.float_x))
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                     ->  Materialize
                           Output: s2.id, s2.float_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.float_x
                                 Filter: (s2.key = 2)
(18 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.float_x,s2.id as id2,s2.float_x from strom_test s1 left outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.float_x between s2.float_x and s2.float_x+0.05) as t where t.rowid%1000 = 0 and t.id2 is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.float_x, t.id2, t.float_x_1
   Filter: ((t.id2 IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.float_x, s2.id, s2.float_x
         ->  Sort
               Output: s1.id, s2.id, s1.float_x, s2.float_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.float_x, s2.float_x
                     Join Filter: ((s1.key = 1) AND (s1.float_x >= s2.float_x) AND (s1.float_x <= (s2.float_x + '0.05'::double precision)))
                     ->  Seq Scan on public.strom_test s1
                           Output: s1.id, s1.key, s1.smlint_x, s1.integer_x, s1.bigint_x, s1.real_x, s1.float_x, s1.nume_x, s1.smlsrl_x, s1.serial_x, s1.bigsrl_x
                     ->  Materialize
                           Output: s2.id, s2.float_x
                           ->  Seq Scan on public.strom_test s2
                                 Output: s2.id, s2.float_x
                                 Filter: (s2.key = 2)
(18 rows)

--Right Outer Join ( REVERSE inner and outer )
explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.float_x,s2.id as id2,s2.float_x from strom_test s1 right outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.float_x > s2.float_x) as t where t.rowid%1000 = 0 and t.id is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.float_x, t.id2, t.float_x_1
   Filter: ((t.id IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.float_x, s2.id, s2.float_x
         ->  Sort
               Output: s1.id, s2.id, s1.float_x, s2.float_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.float_x, s2.float_x
                     Join Filter: ((s2.key = 2) AND (s1.float_x > s2.float_x))
                     ->  Seq Scan on public.strom_test s2
                           Output: s2.id, s2.key, s2.smlint_x, s2.integer_x, s2.bigint_x, s2.real_x, s2.float_x, s2.nume_x, s2.smlsrl_x, s2.serial_x, s2.bigsrl_x
                     ->  Materialize
                           Output: s1.id, s1.float_x
                           ->  Seq Scan on public.strom_test s1
                                 Output: s1.id, s1.float_x
                                 Filter: (s1.key = 1)
(18 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.float_x,s2.id as id2,s2.float_x from strom_test s1 right outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.float_x < s2.float_x) as t where t.rowid%1000 = 0 and t.id is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.float_x, t.id2, t.float_x_1
   Filter: ((t.id IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.float_x, s2.id, s2.float_x
         ->  Sort
               Output: s1.id, s2.id, s1.float_x, s2.float_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.float_x, s2.float_x
                     Join Filter: ((s2.key = 2) AND (s1.float_x < s2.float_x))
                     ->  Seq Scan on public.strom_test s2
                           Output: s2.id, s2.key, s2.smlint_x, s2.integer_x, s2.bigint_x, s2.real_x, s2.float_x, s2.nume_x, s2.smlsrl_x, s2.serial_x, s2.bigsrl_x
                     ->  Materialize
                           Output: s1.id, s1.float_x
                           ->  Seq Scan on public.strom_test s1
                                 Output: s1.id, s1.float_x
                                 Filter: (s1.key = 1)
(18 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.float_x,s2.id as id2,s2.float_x from strom_test s1 right outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.float_x >= s2.float_x) as t where t.rowid%1000 = 0 and t.id is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.float_x, t.id2, t.float_x_1
   Filter: ((t.id IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.float_x, s2.id, s2.float_x
         ->  Sort
               Output: s1.id, s2.id, s1.float_x, s2.float_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.float_x, s2.float_x
                     Join Filter: ((s2.key = 2) AND (s1.float_x >= s2.float_x))
                     ->  Seq Scan on public.strom_test s2
                           Output: s2.id, s2.key, s2.smlint_x, s2.integer_x, s2.bigint_x, s2.real_x, s2.float_x, s2.nume_x, s2.smlsrl_x, s2.serial_x, s2.bigsrl_x
                     ->  Materialize
                           Output: s1.id, s1.float_x
                           ->  Seq Scan on public.strom_test s1
                                 Output: s1.id, s1.float_x
                                 Filter: (s1.key = 1)
(18 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.float_x,s2.id as id2,s2.float_x from strom_test s1 right outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.float_x <= s2.float_x) as t where t.rowid%1000 = 0 and t.id is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.float_x, t.id2, t.float_x_1
   Filter: ((t.id IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.float_x, s2.id, s2.float_x
         ->  Sort
               Output: s1.id, s2.id, s1.float_x, s2.float_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.float_x, s2.float_x
                     Join Filter: ((s2.key = 2) AND (s1.float_x <= s2.float_x))
                     ->  Seq Scan on public.strom_test s2
                           Output: s2.id, s2.key, s2.smlint_x, s2.integer_x, s2.bigint_x, s2.real_x, s2.float_x, s2.nume_x, s2.smlsrl_x, s2.serial_x, s2.bigsrl_x
                     ->  Materialize
                           Output: s1.id, s1.float_x
                           ->  Seq Scan on public.strom_test s1
                                 Output: s1.id, s1.float_x
                                 Filter: (s1.key = 1)
(18 rows)

explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.float_x,s2.id as id2,s2.float_x from strom_test s1 right outer join strom_test s2 on s1.key=1 and s2.key=2 and s1.float_x between s2.float_x and s2.float_x+0.05) as t where t.rowid%1000 = 0 and t.id is NULL;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on t
   Output: t.rowid, t.id, t.float_x, t.id2, t.float_x_1
   Filter: ((t.id IS NULL) AND ((t.rowid % '1000'::bigint) = 0))
   ->  WindowAgg
         Output: row_number() OVER (?), s1.id, s1.float_x, s2.id, s2.float_x
         ->  Sort
               Output: s1.id, s2.id, s1.float_x, s2.float_x
               Sort Key: s1.id, s2.id
               ->  Nested Loop Left Join
                     Output: s1.id, s2.id, s1.float_x, s2.float_x
                     Join Filter: ((s2.key = 2) AND (s1.float_x >= s2.float_x) AND (s1.float_x <= (s2.float_x + '0.05'::double precision)))
                     ->  Seq Scan on public.strom_test s2
                           Output: s2.id, s2.key, s2.smlint_x, s2.integer_x, s2.bigint_x, s2.real_x, s2.float_x, s2.nume_x, s2.smlsrl_x, s2.serial_x, s2.bigsrl_x
                     ->  Materialize
                           Output: s1.id, s1.float_x
                           ->  Seq Scan on public.strom_test s1
                                 Output: s1.id, s1.float_x
                                 Filter: (s1.key = 1)
(18 rows)

--Full Join ( NOT supported error )
explain (verbose, costs off, timing off) select * from (select row_number() over(order by s1.id,s2.id) as rowid,s1.id,s1.float_x,s2.id as id2,s2.float_x from strom_test s1 FULL join strom_test s2 on s1.key=1 and s2.key=2 and s1.float_x > s2.float_x) as t where t.rowid%1000 = 0 and t.id is NULL;
ERROR:  FULL JOIN is only supported with merge-joinable or hash-joinable join conditions
